{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\\\u674E\\u5A01\\\\Desktop\\\\my_works\\\\work_0627\\\\pages\\\\index.js\";\nimport React from \"react\";\nimport { createStore } from 'redux';\n/**\r\n * This is a reducer, a pure function with (state, action) => state signature.\r\n * It describes how an action transforms the state into the next state.\r\n *\r\n * The shape of the state is up to you: it can be a primitive, an array, an object,\r\n * or even an Immutable.js data structure. The only important part is that you should\r\n * not mutate the state object, but return a new object if the state changes.\r\n *\r\n * In this example, we use a `switch` statement and strings, but you can use a helper that\r\n * follows a different convention (such as function maps) if it makes sense for your\r\n * project.\r\n */\n\nfunction counter() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n\n    case 'DECREMENT':\n      return state - 1;\n\n    default:\n      return state;\n  }\n} // Create a Redux store holding the state of your app.\n// Its API is { subscribe, dispatch, getState }.\n\n\nvar store = createStore(counter); // You can use subscribe() to update the UI in response to state changes.\n// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.\n// However it can also be handy to persist the current state in the localStorage.\n\nstore.subscribe(function () {\n  return console.log(store.getState());\n}); // The only way to mutate the internal state is to dispatch an action.\n// The actions can be serialized, logged or stored and later replayed.\n\nstore.dispatch({\n  type: 'INCREMENT'\n}); // 1\n\nstore.dispatch({\n  type: 'INCREMENT'\n}); // 2\n\nstore.dispatch({\n  type: 'DECREMENT'\n}); // 1\n\nexport default (function () {\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45\n    },\n    __self: this\n  }, \"Welcome to next.js!\");\n});","map":{"version":3,"sources":["C:\\Users\\李威\\Desktop\\my_works\\work_0627\\pages\\index.js"],"names":["createStore","counter","state","action","type","store","subscribe","console","log","getState","dispatch"],"mappings":";;AAAA,SAASA,WAAT,QAA4B,OAA5B;AAEA;;;;;;;;;;;;;AAYA,SAASC,OAAT,GAAoC;AAAA,MAAnBC,KAAmB,uEAAX,CAAW;AAAA,MAARC,MAAQ;;AAClC,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,WAAL;AACE,aAAOF,KAAK,GAAG,CAAf;;AACF,SAAK,WAAL;AACE,aAAOA,KAAK,GAAG,CAAf;;AACF;AACE,aAAOA,KAAP;AANJ;AAQD,C,CAED;AACA;;;AACA,IAAIG,KAAK,GAAGL,WAAW,CAACC,OAAD,CAAvB,C,CAEA;AACA;AACA;;AAEAI,KAAK,CAACC,SAAN,CAAgB;AAAA,SAAMC,OAAO,CAACC,GAAR,CAAYH,KAAK,CAACI,QAAN,EAAZ,CAAN;AAAA,CAAhB,E,CAEA;AACA;;AACAJ,KAAK,CAACK,QAAN,CAAe;AAAEN,EAAAA,IAAI,EAAE;AAAR,CAAf,E,CACA;;AACAC,KAAK,CAACK,QAAN,CAAe;AAAEN,EAAAA,IAAI,EAAE;AAAR,CAAf,E,CACA;;AACAC,KAAK,CAACK,QAAN,CAAe;AAAEN,EAAAA,IAAI,EAAE;AAAR,CAAf,E,CACA;;AAEA,gBAAe;AAAA,SAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAAN;AAAA,CAAf","sourcesContent":["import { createStore } from 'redux'\r\n\r\n/**\r\n * This is a reducer, a pure function with (state, action) => state signature.\r\n * It describes how an action transforms the state into the next state.\r\n *\r\n * The shape of the state is up to you: it can be a primitive, an array, an object,\r\n * or even an Immutable.js data structure. The only important part is that you should\r\n * not mutate the state object, but return a new object if the state changes.\r\n *\r\n * In this example, we use a `switch` statement and strings, but you can use a helper that\r\n * follows a different convention (such as function maps) if it makes sense for your\r\n * project.\r\n */\r\nfunction counter(state = 0, action) {\r\n  switch (action.type) {\r\n    case 'INCREMENT':\r\n      return state + 1\r\n    case 'DECREMENT':\r\n      return state - 1\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\n// Create a Redux store holding the state of your app.\r\n// Its API is { subscribe, dispatch, getState }.\r\nlet store = createStore(counter)\r\n\r\n// You can use subscribe() to update the UI in response to state changes.\r\n// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.\r\n// However it can also be handy to persist the current state in the localStorage.\r\n\r\nstore.subscribe(() => console.log(store.getState()))\r\n\r\n// The only way to mutate the internal state is to dispatch an action.\r\n// The actions can be serialized, logged or stored and later replayed.\r\nstore.dispatch({ type: 'INCREMENT' })\r\n// 1\r\nstore.dispatch({ type: 'INCREMENT' })\r\n// 2\r\nstore.dispatch({ type: 'DECREMENT' })\r\n// 1\r\n\r\nexport default () => <div>Welcome to next.js!</div>"]},"metadata":{},"sourceType":"module"}